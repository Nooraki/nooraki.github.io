export default {
  async fetch(request, env, ctx) {
    if (request.method === 'POST') {
      const update = await request.json();
      await handleUpdate(update, env);
      return new Response('OK', { status: 200 });
    }
    return new Response('Worker is running', { status: 200 });
  },
};

// Function to get the rules text with HTML formatting
function getRulesText() {
  return `<b>بخش اول: قوانین برای کارفرما و اپراتورها</b>\n` +
         `1. <b>حفظ محرمانگی</b>\n` +
         `    * تمامی اطلاعات مشتریان (نام، شماره تماس، محتوای گفتگو) محرمانه تلقی می‌شود.\n` +
         `    * افشای هرگونه اطلاعات به شخص ثالث بدون مجوز مدیریت ممنوع است.\n` +
         `2. <b>پاسخ‌گویی محترمانه و به‌موقع</b>\n` +
         `    * اپراتورها موظف‌اند با لحن مؤدبانه، صبور و حرفه‌ای پاسخ‌گو باشند.\n` +
         `    * در ساعات تعیین‌شده باید در دسترس باشند و پاسخ به مشتریان را به تعویق نیندازند.\n` +
         `3. <b>عدم سوءاستفاده از ربات</b>\n` +
         `    * استفاده از ربات برای منافع شخصی خارج از چارچوب کاری تعریف‌شده، ممنوع است.\n` +
         `    * هرگونه ارسال محتوای غیرمرتبط یا تبلیغاتی بدون هماهنگی مدیریت ممنوع است.\n` +
         `4. <b>تعهدات مالی اپراتور</b>\n` +
         `    * اپراتور موظف است ماهیانه <b>۵٪ از دریافتی خود</b> را به حساب مدیریت به‌عنوان حق عضویت پرداخت کند.\n` +
         `    * برای شروع همکاری، اپراتور باید مبلغ <b>200,000 تومان</b> به‌عنوان <b>حسن انجام کار</b> به حساب مدیریت واریز کند.\n` +
         `    * این مبلغ نزد مدیریت امانت باقی می‌ماند و در زمان خروج اپراتور، در صورت عدم تخلف، به‌طور کامل بازگردانده می‌شود.\n\n` +
         `<b>بخش دوم: قوانین برای مشتریان</b>\n` +
         `1. <b>حفظ احترام متقابل</b>\n` +
         `    * مشتری موظف است با لحن محترمانه و بدون توهین یا تهدید با اپراتورها گفتگو کند.\n` +
         `    * استفاده از کلمات ناشایست یا رفتار نامناسب منجر به قطع دسترسی خواهد شد.\n` +
         `2. <b>محرمانگی</b>\n` +
         `    * شماره تماس مشتری تنها برای مدیریت ثبت می‌شود و در اختیار اپراتورها قرار نمی‌گیرد.\n` +
         `    * ارسال آیدی یا شماره تماس بین مشتری و اپراتور اکیداً ممنوع است و منجر به مسدودیت حساب می‌شود.\n` +
         `3. <b>تعهدات مالی مشتری</b>\n` +
         `    * مدیریت تضمین می‌کند که کار مشتری به‌درستی انجام شود.\n` +
         `    * مشتری موظف است پیش از شروع کار، <b>۵۰٪ از مبلغ توافق‌شده (تا سقف 200,000 تومان)</b> را به‌عنوان پیش‌پرداخت به حساب اپراتور واریز کند.\n` +
         `    * هزینه نهایی توافقی است و می‌تواند بر اساس قرارداد بین اپراتور و مشتری متغیر باشد.\n` +
         `    * در صورت عدم پرداخت توسط مشتری، کلیه اطلاعات وی برای اپراتور ارسال می‌شود تا بتواند از طریق مراجع قضایی برای ثبت شکایت اقدام نماید.\n` +
         `4. <b>محدودیت در محتوا</b>\n` +
         `    * ارسال محتوای غیرقانونی، خلاف عرف، یا نقض‌کننده حقوق دیگران ممنوع است.\n` +
         `    * در صورت تخلف، دسترسی کاربر مسدود خواهد شد و مسئولیت حقوقی بر عهده کاربر است.\n` +
         `5. <b>پایان گفتگو</b>\n` +
         `    * مشتری می‌تواند هر زمان با دستور /end مکالمه را پایان دهد.\n` +
         `    * اپراتور نیز در صورت نیاز می‌تواند گفتگو را به پایان برساند یا به اپراتور دیگر منتقل کند.\n\n` +
         `<b>بخش سوم: تعهدات مدیریت</b>\n` +
         `1. <b>ضمانت انجام کار</b>\n` +
         `    * مدیریت تضمین می‌کند که سفارش مشتری به‌درستی انجام شود.\n` +
         `    * در صورت بروز مشکل، مدیریت میان مشتری و اپراتور داوری می‌کند.\n` +
         `2. <b>حفظ اطلاعات</b>\n` +
         `    * مدیریت موظف است شماره تلفن‌ها و اطلاعات شخصی مشتریان را فقط برای اهداف پشتیبانی نگهداری کند.\n` +
         `    * اطلاعات تماس بین اپراتور و مشتری رد و بدل نمی‌شود و فقط مدیریت به آن دسترسی دارد.\n` +
         `3. <b>کنترل و نظارت</b>\n` +
         `    * مدیریت در صورت مشاهده تخلف (از سوی اپراتور یا مشتری) حق قطع همکاری یا مسدودسازی حساب را دارد.\n` +
         `    * تمامی داده‌ها مطابق با قوانین پلتفرم تلگرام و مقررات قوانین جمهوری اسلامی ایران ذخیره‌سازی می‌شوند.`;
}

// Function to get the user guide text
function getGuideText() {
  return `<b> راهنمای استفاده از ربات </b> 🤖\n\n` +
         `🔹 <b>/start</b>: برای شروع کار با ربات و ثبت شماره تلفن.\n` +
         `🔹 <b>/operator</b>: برای مشاهده لیست اپراتورها و انتخاب یکی از آنها جهت شروع گفتگو.\n` +
         `🔹 <b>/end</b>: برای پایان دادن به گفتگوی فعلی با اپراتور.\n` +
         `🔹 <b>/rules</b>: برای مشاهده مجدد قوانین و راهنما.\n\n` +
         `پس از اتصال به یک اپراتور، می‌توانید پیام‌های خود را به صورت عادی ارسال کنید.`;
}

async function handleUpdate(update, env) {
  const botToken = env.BOT_TOKEN;
  const adminId = env.ADMIN_ID;
  const operators = [];
  for (let i = 1; i <= 7; i++) {
    const operatorId = env["OPERATOR_" + i + "_ID"];
    if (operatorId) { // Only add operator if ID is defined
        operators.push({
            id: operatorId,
            name: env["OPERATOR_" + i + "_NAME"],
        });
    }
  }

  const tgApi = async (method, body) => {
    const response = await fetch(`https://api.telegram.org/bot${botToken}/${method}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
        const error = await response.json();
        console.error(`Telegram API error: ${response.status} ${response.statusText}`, error);
    }
    return response.json();
  };
  
  const { message, callback_query } = update;

  if (message) {
    const { chat: { id: chatId }, from: { id: userId, first_name, last_name, username }, text, contact, reply_to_message } = message;
    const userIdStr = userId.toString();
    const isOperator = operators.some(op => op.id === userIdStr);

    if (text === '/start') {
      await tgApi('sendMessage', {
        chat_id: chatId,
        text: 'به ربات ما خوش آمدید! لطفاً با کلیک روی دکمه زیر، شماره تلفن خود را ارسال نمایید.',
        reply_markup: {
          keyboard: [[{ text: 'ارسال شماره تلفن', request_contact: true }]],
          one_time_keyboard: true,
          resize_keyboard: true,
        },
      });
    } else if (contact) {
      const existingUserData = await env.USERS.get(userIdStr);
      if (existingUserData) {
        await tgApi('sendMessage', { chat_id: chatId, text: 'شما قبلاً ثبت‌نام کرده‌اید. برای مشاهده قوانین، از دستور /rules استفاده کنید.' });
        return;
      }

      const phone = contact.phone_number;
      const userData = {
        phone,
        first_name,
        last_name: last_name || '',
        username: username || '',
        current_operator: null,
      };
      await env.USERS.put(userIdStr, JSON.stringify(userData));

      await tgApi('sendMessage', {
        chat_id: adminId,
        text: `کاربر جدید ثبت شد:\nID: ${userId}\nنام: ${first_name} ${last_name || ''}\nنام کاربری: ${username || 'نامشخص'}\nشماره تلفن: ${phone}`,
      });
      
      // Send rules
      await tgApi('sendMessage', { chat_id: chatId, text: getRulesText(), parse_mode: 'HTML' });
      // Send guide
      await tgApi('sendMessage', { chat_id: chatId, text: getGuideText(), parse_mode: 'HTML' });

      if (isOperator) {
        await tgApi('sendMessage', { chat_id: chatId, text: '✅ ثبت‌نام شما به عنوان اپراتور با موفقیت انجام شد. منتظر دریافت پیام از مشتریان بمانید.' });
      } else {
        await tgApi('sendMessage', { chat_id: chatId, text: '✅ ثبت‌نام شما با موفقیت انجام شد. اکنون می‌توانید با دستور /operator یک اپراتور را برای گفتگو انتخاب نمایید.' });
      }
    } else if (text === '/rules') {
      const userDataStr = await env.USERS.get(userIdStr);
      if (!userDataStr) {
        await tgApi('sendMessage', { chat_id: chatId, text: 'لطفاً ابتدا با دستور /start ثبت‌نام کنید.' });
        return;
      }
      
      // Send rules
      await tgApi('sendMessage', { chat_id: chatId, text: getRulesText(), parse_mode: 'HTML' });
      // Send guide
      await tgApi('sendMessage', { chat_id: chatId, text: getGuideText(), parse_mode: 'HTML' });

    } else if (text === '/operator') {
      // Check if registered first
      const userDataStr = await env.USERS.get(userIdStr);
      if (!userDataStr) {
        await tgApi('sendMessage', { chat_id: chatId, text: 'لطفاً ابتدا با دستور /start ثبت‌نام کنید.' });
        return;
      }
      
      const shuffledOperators = [...operators].sort(() => Math.random() - 0.5);
      const inlineKeyboard = shuffledOperators.map(op => [{ text: op.name, callback_data: `connect_${op.id}` }]);

      await tgApi('sendMessage', {
        chat_id: chatId,
        text: 'لطفا یکی از اپراتورهای زیر را برای شروع گفتگو انتخاب کنید:',
        reply_markup: { inline_keyboard: inlineKeyboard },
      });
    } else if (text === '/end') {
      const userDataStr = await env.USERS.get(userIdStr);
      if (userDataStr) {
        const userData = JSON.parse(userDataStr);
        if (userData.current_operator) {
          await tgApi('sendMessage', { chat_id: userData.current_operator, text: 'کاربر به گفتگو پایان داد.' });
        }
        userData.current_operator = null;
        await env.USERS.put(userIdStr, JSON.stringify(userData));
        await tgApi('sendMessage', { chat_id: chatId, text: 'مکالمه به پایان رسید. برای شروع مجدد، از دستور /operator استفاده کنید.' });
      }
    } else {
      const userDataStr = await env.USERS.get(userIdStr);
      if (!userDataStr) {
        await tgApi('sendMessage', { chat_id: chatId, text: 'لطفاً ابتدا با دستور /start ثبت‌نام کنید.' });
        return;
      }
      const userData = JSON.parse(userDataStr);

      if (isOperator) {
        if (reply_to_message) {
          const replyMsgId = reply_to_message.message_id;
          const mapKey = `message_map_${userIdStr}_${replyMsgId}`;
          const targetUserId = await env.USERS.get(mapKey);
          if (targetUserId) {
            await tgApi('copyMessage', {
              chat_id: targetUserId,
              from_chat_id: chatId,
              message_id: message.message_id,
            });
          } else {
            await tgApi('sendMessage', { chat_id: chatId, text: 'پیام مرتبط برای پاسخ یافت نشد. ممکن است کاربر مکالمه را پایان داده باشد.' });
          }
        } else {
          await tgApi('sendMessage', { chat_id: chatId, text: 'لطفاً برای پاسخ دادن، پیام کاربر را ریپلای (Reply) کنید.' });
        }
      } else {
        if (!userData.current_operator) {
          await tgApi('sendMessage', { chat_id: chatId, text: 'شما به هیچ اپراتوری متصل نیستید. لطفاً ابتدا با دستور /operator یک اپراتور انتخاب کنید.' });
          return;
        }
        const opId = userData.current_operator;
        const sentResponse = await tgApi('copyMessage', {
          chat_id: opId,
          from_chat_id: chatId,
          message_id: message.message_id,
        });
        if (sentResponse.ok) {
            const sentMsgId = sentResponse.result.message_id;
            const mapKey = `message_map_${opId}_${sentMsgId}`;
            // Set an expiration for the mapping (e.g., 24 hours) to auto-clean KV
            await env.USERS.put(mapKey, userIdStr, { expirationTtl: 86400 });
        }
      }
    }
  } else if (callback_query) {
    const { id: queryId, from: { id: userId }, data, message: { chat: { id: chatId } } } = callback_query;
    const userIdStr = userId.toString();

    if (data.startsWith('connect_')) {
      const opId = data.split('_')[1];
      const userDataStr = await env.USERS.get(userIdStr);
      if (userDataStr) {
        const userData = JSON.parse(userDataStr);
        const prevOp = userData.current_operator;
        userData.current_operator = opId;
        await env.USERS.put(userIdStr, JSON.stringify(userData));

        const operator = operators.find(op => op.id === opId);
        const opName = operator ? operator.name : 'اپراتور';

        await tgApi('answerCallbackQuery', { callback_query_id: queryId, text: `شما به ${opName} متصل شدید.` });
        
        // Edit the original message to remove the inline keyboard
        await tgApi('editMessageText', {
            chat_id: chatId,
            message_id: callback_query.message.message_id,
            text: `شما اکنون به <b>${opName}</b> متصل هستید. پیام‌های خود را ارسال کنید.`,
            parse_mode: 'HTML',
            reply_markup: {} // remove keyboard
        });

        await tgApi('sendMessage', { chat_id: opId, text: `کاربر جدید <b>${userData.first_name} ${userData.last_name || ''}</b> به شما متصل شد.`, parse_mode: 'HTML' });

        if (prevOp && prevOp !== opId) {
          await tgApi('sendMessage', { chat_id: prevOp, text: 'کاربر به اپراتور دیگری متصل شد و مکالمه فعلی پایان یافت.' });
        }
      }
    }
  }
}            این ربات نیاز به تغییرات داره اولا تمام اپراتور ها رو از بخش VALIUBEL AND SECRET حذف کردم میخوام تو خود کد بشه اون ها رو دونه دونه وارد کرد هر تعدادی که میخوام . تمام پیام هایبین اپراتور و مشتری رو واسه ادمین بفرست مثلا بگو این پیام از اپراتور خانم نوری مثلا به مشتری آقای غلامی مثلا